---
layout: post
title:  "金融系统设计难点与FIX协议"
date:   2017-07-17 21:01:00 +0800
---

* 还在努力更新中

* 目录
{:toc}

[TOC]

# 金融系统设计难点与FIX协议

## 1. 前言

## 1.1 简单介绍本文

* 本文的内容：
  * 设计金融系统时面临的一些问题，描述这些问题发生的具体场景。
  * 针对每种问题我们有哪些可选解决思路，各种思路的优缺点对比。
  * 简单介绍下FIX协议。针对每种问题，FIX使用了哪种解决思路。

* 本文不会讲述：
  * 不会讲述FIX协议的具体消息格式及使用方法。属于具体应用范畴，有大量文章讲述。本文的重点是分析问题和解决问题的思路，不会太多的涉及实操层面。
  * 不会对某些难点问题进行更深入探讨、列举更多的业内解决方案。我的知识和实践经验有限，我们富途的系统也在朝着更好的方向做改进，后续我们团队有更多实践积累了，有机会相关同事再来跟大家分享一下。

## 1.1 设计金融系统会面临哪些难点？

> 网络传输是异步的、不可靠的。金融系统的请求量通常不是很大，但对数据的准确性、系统稳定性有更加苛刻的要求。这跟我们常接触的互联网应用的系统截然不同。

1. 消息完整性：刚刚向对方发送了一条消息，网络就立刻发生了中断，不确定对方是否收到了消息。怎么办？
2. 消息时序性：不确定对方是否收到了某条消息 或 对方没有对某消息做出应答，我能继续发送新的消息给对方吗？
3. 容灾：我的服务器故障了，当时有些刚刚收到的消息没来得及保存和处理。服务器恢复后，那些没来及保存的消息去哪里找？
4. 数据操作的ACID保证：数据库通常都要支持的特性。如果不保证做到ACID，会发生什么情况？
5. 容量：7×24小时不间断交易，订单还可以跨多日有效，这给系统容量带来的挑战有哪些？
6. 性能：开盘的瞬间有大量的订单要发送出去，可能有大量的成交通知，如何更快地传输消息？
7. 请求-应答-推送的对应：收到了对方的应答或交易推送，这个应答或推送是对应我的哪个请求的？
8. 大数字和浮点数：编程语言里的整数通常是有取值范围的，IEEE754标准是有精度损失的，这会导致哪些问题？

## 1.2 FIX协议是什么？

* 百度百科：

> FIX协议是由国际FIX协会组织提供的一个开放式协议，目的是推动国际贸易电子化的进程，在各类参与者之间，包括投资经理、经纪人，买方、卖方建立起实时的电子化通讯协议。FIX协议的目标是把各类证券金融业务需求流程格式化，使之成为一个个可用计算机语言描述的功能流程，并在每个业务功能接口上统一交换格式，方便各个功能模块的连接。

* FIX协议也有客户端和服务端的概念。比如跟港交所之间，富途是客户端，交易所是服务端。富途的系统启动后使用指定账号登录交易所的服务器。

## 2. 消息完整性

> 如果消息在系统间传输过程中发生了丢失，后果不堪设想。比如交易所发给我们的成交通知被我们漏掉了。

### 2.1 发生问题的场景

1. 场景A，没有响应确认机制：

  * 发送方通过网络发送了个一个消息，然后网络立刻发生了中断。
  * 接收方由于网络中断，没有收到这条消息。
  * 发送方认为消息是发送出去的，因此也没有将该消息做重发。
  * 该消息就永远不会被接收方收到了。

2. 场景B，有响应确认机制，但没有重发处理机制：

  * 发送方通过网络发送了个一个消息，然后网络立刻发生了中断。
  * 接收方收到了这条消息。但由于网络中断，响应无法发送。
  * 发送方等待响应超时，且网络有中断，认为发生了丢包。
  * 网络恢复，发送方立刻再次发送了消息。
  * 接收方再次收到消息，当做第二条消息，再次做了处理。

3. 场景C，接收方缺乏发现消息丢失的机制：

  * 发送方尝试发送消息。但由于发送方系统bug，该消息实际上没有发出，而是被丢弃了。
  * 发送方的bug同时也导致等待超时的逻辑失效了。
  * 发送方发送第二条消息，接收方成功收到了第二条消息。
  * 双方都没有发现第一条消息丢失的情况。

* 引发消息不完整的原因多种多样的：

  * 网络是不可靠的：使用了本身就会丢包的UDP，使用TCP但TCP连接也是会断线的。
  * 发送方故障：发送方消息发送失败，重发机制失效但接收方又没有收到消息。
  * 接收方故障：收到消息后系统从崩溃中恢复后需要确认消息是否完整。

### 2.2 解决思路有哪些

* 仔细分析下以上几个场景的问题，归纳一下，我们面临的难题就是“发现问题和解决问题”两点：
  1. 如何发现消息丢失：发送方需要接收方提供某种确认机制来发现消息的丢失，接收方需要发送方提供前后多条消息的关联关系来发现消息的丢失。
  2. 如何补全丢失的消息：重发是一种很自然的思路，但他要求发送发要能保存历史消息，接收方要能识别消息是之前哪条消息的重发。

* 这其实是很典型的问题，有大量的可参考的解决方案，不需要我们自己发明创造：
  1. 计算机专业课程的《网络原理》中，在讲述网络协议的进化过程时，也是面临类似的问题，网络协议是如何解决当时问题的呢？
  2. 常见的支付平台对商户系统提供接入时，也都有提供手段来发现和补全丢失的消息。

* 常用基本手段：

| 对比 \ 编号 | 手段1 | 手段2 | 手段3 |
| ------ | ------ | ------ | ------ |
| 简称 | 流水对账单 | 接收方确认 | 递增编号 |
| 发现机制 | 系统运行一段时间后，<br/>一方得到对方的历史流水，<br/>与本地记录对比发现差异。 | 发送方等待接收方的确认，<br/>超时就认为消息丢失。 | 接收方发现消息编号不连续<br/>就认为消息丢失。 |
| 发现者 | 可以是任何一方 | 发送方 | 接收方 |
| 发现速度 | 慢，取决于对账频率。 | 较快，取决于超时时间。 | 较快，取决于消息密集程度 |
| 消息有编号 | 不一定 | 不一定 | 有 |
| 有编号的优点 | 发现具体有问题的消息是哪条 | 接收方可以乱序发送响应 | |
| 补全机制 | 根据对账单直接补全 | 发送方主动重发，<br/>接收方能识别重发。 | 接收方请求发送方重发，<br/>或接收方向发送方查询。 |
| 补全速度 | 慢，因为发现就慢 | 实时补全 | 实时补全 |
| 增量补全 | 有编号就可以增量 | 是 | 是 |
| 其他优点 | | 1. 部分情况下可以保证消息的顺序性<br/>（UDP一发一收，TCP可多发多收），<br/>2. 但很容易写出bug代码。 | 1. 可以严格保证消息顺序（网络层协议无关），<br/>2. 接收方可主动发起重发，对接收方更灵活。 |
| 其他缺点 | | 接收方故障导致发送方重发雪崩 | 发送方需要保存历史消息应对重发请求 |
| 实现难度 | 简单 | 较简单 | 较复杂 |

* 每种手段都有各自的优缺点。通常设计系统的时候不会只用一种手段，而是综合使用多种手段，并根据自己的需要对手段进行一些调整。

* 一些常见的系统设计所采用的手段：

| 系统 | 手段 | 备注 |
| ------ | ------ | ------ |
| Redis客户端与服务端 | 手段2（接收方应答、无消息编号） | 无补全，发现问题直接断连。 |
| 支付宝财付通与商户系统 | 手段1（流水对账单、有消息编号）+<br/>手段2（接收方应答、有消息编号）| 重发有次数限制，<br/>对账以天为单位。 |
| TCP的设计 | 手段2（接收方应答、有消息编号）+ 手段3（递增编号）| 滑动窗口机制，既实现了流量控制，<br/>还保证了可能重发的范围只是最近的一部分消息。 |
| RabbitMQ的ACK机制 | 手段2（接收方应答、无消息编号）| 发送方不重发，<br/>接收方处理消息有问题需断连。 |

* 问题：我们的牛牛客户端跟后台的通信是用了哪种手段？

### 2.3 FIX协议如何解决该问题

* FIX协议使用了手段3（递增编号），补全是接收方向发送方请求重发。

* FIX协议的通信双方都会互相发送消息（不是简单的只有客户端一方发送请求消息），因此双方都会对发出的消息做编号，双方都要检查收到的消息是否的连续编号的。如果不连续，双方都要能够请求对方重发，双发都要有重发某段历史消息的能力。

* 这种实现比较复杂，而且这还只是两个节点之间的通信。对于一个复杂的系统，消息可能是在多个节点之间中转的，如果没有比较成熟的中间件，系统实现成本会非常大。

* 为了及时发现通道故障，客户端还要发送心跳。心跳消息同业务消息是一起编号的，因此也有助于及早发现消息丢失。

* 通信的任何一方收到编号不连续的消息（产生了”消息空洞“）时，都需要立刻向对方请求补全缺少的消息。

## 3. 消息时序性

### 3.1 几个发生问题的场景

1. 场景A，富途与交易所之间的乱序导致的问题：
  * 假设有个买入订单待成交，股数为100股。一个可能的正常的消息序列为：
    - a. 客户请求将订单改为200股，富途的系统发送`改单消息`给交易所。
    - b. 交易所发送`改单成功消息`给富途，订单更新为200股待成交。
    - c. 然后，交易所发送`成交消息`给富途，订单全部成交，成交股数为200股。
  * 以上是正常的消息顺序。但假设，在步骤a完成之后，交易所与富途之间的网络发生故障，导致步骤b的的消息未能发送给富途。
  * 网络恢复后，交易所先将步骤c中的成交消息发送给富途，订单更新为全部成交。
  * 然后某种机制发现之前的`改单成功消息`还没有发送成功，因此交易所重发该消息。
  * 富途收到`改单成功消息`，发现该消息确实是第一次收到，将订单更新为200股待成交。
  * 这导致订单还在占用客户的购买力。

2. 场景B，后台推送给牛牛的订单更新乱序导致的问题：
  * 假设客户输入买入订单，股数为100股，一个可能的正常的订单更新消息序列为：
    - a. 订单`生成消息`，待成交股数为100股。
    - b. 订单`成交消息`，全部成交，成交股数为100股。
  * 以上是正常的消息顺序。但假设，由于后台系统的bug，两条消息顺序颠倒了。客户端最终展现的状态很可能会是待成交。
  * 这导致客户无法撤单、改单，因为订单在后台其实是已经成交了的。

* 引发消息时序错乱的原因多种多样的，但总的来讲就是因为“并发”：

  * 网络本身的并发：比如使用了本身就是乱序到达的UDP协议。
  * 多条传输通道并行传输：并行传输肯定会导致消息乱序到达接收方。
  * 发送方是分布式系统：消息产生的源头就是乱序的，如果按照产生顺序进行发送，那也是乱序发送的。
  * 接收方是分布式系统：消息即使按顺序到达了接收方，接收方如果将消息乱序分配多个工作节点，那很有可能是乱序处理的。

### 3.2 解决思路有哪些

* 仔细分析下以上几个场景的问题，归纳一下，我们面临的难题也是“发现问题和解决问题”两点：
  - 如何发现消息顺序错乱：提供某种机制，让接收方来发现顺序错乱的问题。发送方对此是无能为力的。
  - 如何解决消息错乱的问题：要么避免消息错乱的发生，要么让接收方对错乱的消息进行排序。

* 这个问题跟完整性问题同样典型，仍然可以参考前面的那些现有解决方案。完整性问题的解决手段中的手段2（接收方确认）和手段3（递增编号）都能帮我们解决时序性的问题。

* 根据并发的原因，我们可以归纳如下基本手段：

| 对比 \ 编号 | 手段1 | 手段2 | 手段3 |
| ------ | ------ | ------ | ------ |
| 解决的问题 | 所有并发 | 乱序发送和乱序传输 | 接收方乱序处理 |
| 实现原理 | 一收一发，<br/>发送方在收到某条消息的应答<br/>之前，不会发送新的消息。 | 发送方保证按顺序发送消息，<br/>就可以批量发送大量消息，<br/>不需要逐一等待应答。 | 消息可以排序，<br/>接收方保证按顺序处理。 |
| 要求 | 无任何要求<br/>（因为根本没有并发的可能） | 发送方不可能并发发送，<br/>传输通道不能乱序到达<br/>（比如使用单条TCP长连接） | 接收方要能缓存乱序的消息，<br/>等顺序消息到达后依次处理。 |
| 消息传输效率 | 慢 | 中 | 快 |
| 实现难度 | 简单 | 中等 | 复杂 |

* 每种手段都有各自的优缺点。通常设计系统的时候不会只用一种手段，而是综合使用多种手段，并根据自己的需要对手段进行一些调整。

* 一些常见的系统设计所采用的手段：

| 系统 | 手段 | 备注 |
| ------ | ------ | ------ |
| Redis客户端与服务端 | 手段2（解决乱序发送和乱序传输） | 单条TCP长连接 |
| TCP的设计 | 手段3（解决接收方乱序处理） | 有序列号，会严格按照序列号处理。 |
| RabbitMQ | 手段2（解决乱序发送和乱序传输）| 单条TCP长连接 |

* 问题：我们的牛牛客户端跟后台的通信是用了哪种手段？

### 3.3 FIX协议如何解决该问题

* FIX协议使用了手段3（解决接收方乱序处理）。

* FIX协议在解决消息完整性问题是已经引入了严格的递增消息编号，因此它很自然的选择了按顺序处理消息是很自然的。

* 通信的任何一方收到不连续的消息（产生了”消息空洞“）时，不能处理空洞之后的消息，要等待空洞补全后，按顺序处理。

## 4. 容灾

### 4.1 几个发生问题的场景

### 4.2 解决思路有哪些

### 4.3 FIX协议如何解决该问题

## 5. 数据操作的ACID保证

### 5.1 几个发生问题的场景

### 5.2 解决思路有哪些

### 5.3 FIX协议如何解决该问题

## 4. 请求-应答-推送的对应关系

### 4.1 几个发生问题的场景

### 4.2 解决思路有哪些

### 4.3 FIX协议如何解决该问题

## 7. 容量

### 7.1 几个发生问题的场景

### 7.2 解决思路有哪些

### 7.3 FIX协议如何解决该问题

## 8. 性能

### 8.1 几个发生问题的场景

### 8.2 解决思路有哪些

### 8.3 FIX协议如何解决该问题

## 9. 浮点数精度

### 8.1 几个发生问题的场景

### 8.2 解决思路有哪些

### 8.3 FIX协议如何解决该问题
