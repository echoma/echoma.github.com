---
layout: post
title:  "《effective modern c++》笔记 第7章 并行API"
date:   2017-07-04 13:25:21 +0800
---

* 目录
{:toc}

# 第七章

* c++对并行的支持是一大进步，而且也只是个开始。

* 标准库中有两个`future模板`：`std::future`和`std::shared_future`，大部分情况下这两者的差异不重要，书中讲到的`future`通常同时表示这两者。

## 35. 尽量用任务式的程序设计取代线程式的设计

* 假如要非同步执行doAsyncWork函数，有两种选择：

  1. 使用线程式（thread-based）的设计：`std::threaad t(doAsyncWork);`
  2. 使用任务式（task-based）的设计：`auto fut = std::async(doAsyncWork);`

* 通常任务式的设计有更多好处：

  1. 有返回值。线程式设计是没办法直接获取返回值的。而`std::async`提供get函数轻松获取返回值。
  2. 支持异常捕获。通过get函数可以取得异常。而线程式的设计一旦异常就导致程序终止（通过调用std::terminate）。

* 几个概念要区分清楚：

  1. 硬件线程（hardware thread）：现代的计算机CPU在每个核心上都提供一个以上的线程。
  2. 软件线程（software thread）：操作系统进程内部的线程，排在硬件线程上执行。一旦阻塞（如果等待IO操作、等待互斥量），硬件线程就会切换到其他未阻塞的软件线程来执行。
  3. std::thread：这是C++的类，是底层软件线程在C++的句柄（handle）。当然，一个std::thread也可能不代表任何底层软件线程（而是代表null），可能是因为处于刚刚被构造的状态、曾经作为移动操作的来源等。

* 多线程编程会有两个棘手情况：

  1. 软件线程资源耗尽：软件线程是有限资源，操作系统是限制了线程数量的，如果超出会抛出`std::system_error`异常。
  2. 过度订阅（oversubscription）：线程数量太多，一个线程被系统不停地调度到不同的CPU核心上运行，线程上下文切换成本变得很高。

* `std::async`在面对上述两个棘手问题时是有做了一些工作的：`std::async`不保证会建立新的软件线程。当上述两个棘手情况发生时，计算工作会被调度到`调用get或wait操作`的线程。当然，这可能会对调用get或wait操作的线程造成影响，如果这个线程是负责处理GUI的，那可能会导致界面失去响应。第36条会讲解启动策略来配置这个行为。

* 当然，`std::thread`也有其适用场景：

  1. 需要存取底层线程实现API：有时候需要操作底层的pthread或者Windows threads，因为他们提供了更丰富的功能。`std::thread`会提供`native_handle`成员函数。
  2. 需要针对硬件环境、软件逻辑优化线程的使用：软件逻辑比较特殊，或者硬件特性比较特殊。这种情况下需要开发者自己来调整调度方法。
  3. 要实现标准库没有提供的线程特性：比如线程池。