---
layout: post
title:  "《effective modern c++》笔记 第4章 智能指针"
date:   2017-03-30 13:45:21 +0800
---

* 目录
{:toc}

# 第三章

> c++98中的`auto_ptr`在c++11中已经纯粹是为了兼容老标准而存在了。

> 新增的三种智能指针适用性更好，可用于容器内部，支持搬移操作，而且语义更清晰。

> 原来使用`auto_ptr`的地方都应当义无反顾的使用新的`unique_ptr`，除非是为了兼容老标准。

## 18. 使用std::unique_ptr管理单一所有权的资源

* `unique_ptr`代表单一所有权，体积小(大部分情况和原指针同样大小)，速度快，不支持复制，只支持搬移操作。

* `unique_ptr`默认使用delete删除对象，通过第二个模板参数可以传入`删除子`类型，指定删除操作。

* 可以直接通过类型转化转为`shared_ptr`类型。

## 19. 使用shared_ptr管理共享所有权的资源

* `shared_ptr`使用引用计数来判断对象是否应该被删除了，且其更新引用计数的操作内部都是用atomic来确保线程安全。

* `shared_ptr`内部有两个指针，因此体积是原指针的两倍（标准未定义实现方式，但几乎所有的标准库实现都使用了这种实现）。

* 删除子不是`shared_ptr`的模板参数，而是成员。也就说，同一类型的`shared_ptr`的多个对象可以拥有不同的删除子。这跟`unique_ptr`是不同的。

* 原则上，使用`shared_ptr`是一条**不归路**，一旦将某个原始指针交给`shared_ptr`管理，今后就不应该对原始指针进行操作了。尤其是用同一个原始指针构造多个`shared_ptr`对象，会导致引用计数紊乱。

## 20. 用std::weak_ptr取代可能悬置的std::shared_ptr类指针

* `weak_ptr`类似`shared_ptr`，但不会影响引用计数。`weak_ptr`必须使用`shared_ptr`对象来构造。

* 其`expired()`方法可以用来检查所代表的原始指针指向的对象是否已被释放。

* 有些时候，需求使两个对象各自拥有指向对方的`shared_ptr`，使得引用计数永远不可能变为0，对象永远都不能得到真正的释放。此时将其中一个改为`weak_ptr`就能解决问题。

## 21. 尽量用std::make_unique与std::make_shared取代直接使用new

* 比起先new原始指针再赋值给new出来的智能指针的方式，直接使用make函数精炼很多，而且性能也更高。

* `make_unique`函数在c++14才引入，使用c++11的话就需要自己定义，这很简单(代码见书，使用了variadic template)。但注意不要污染std名字空间，以防今后升级到c++14后发生冲突。

* make函数无法自定义删除子，无法调用对象的大括号构造函数。

* 要注意，使用智能指针（尤其是`shared_ptr`和`weak_ptr`）可能会导致对象的释放比实际预想的要晚，这可能导致更多的内存占用。
